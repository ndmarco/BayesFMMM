# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculates the credible interval for the mean (Functional Data)
#'
#' This function calculates a credible interval with the user specified coverage.
#' In order to run this function, the directory of the posterior samples needs
#' to be specified. The function will return the credible intervals and the median
#' posterior estimate of the mean function at the time points specified by the
#' user (\code{time} variable). The user can specify if they would like the algorithm
#' to automatically rescale the parameters for interpretability (suggested). If
#' the user chooses to rescale, then all class memberships will be rescaled so
#' that at least one observation is in only one class. The user can also specify
#' if they want pointwise credible intervals or simultaneous credible intervals.
#' The simultaneous intervals will likely be wider than the pointwise credible
#' intervals.
#'
#' @name FMeanCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time Vector containing time points of interest
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param k Int containing the cluster group of which you want to get the credible interval for
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param simultaneous Boolean indicating whether or not the credible intervals should be simultaneous credible intervals or pointwise credible intervals
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix containing covariates at points of interest (of dimension W x D (number of points of interest x number of covariates))
#' @param trans_mats Matrix containing transformations of the variables to help with identifiability when K > 2 (of dimension (K x n_iters) x K)
#' @return CI list containing the credible interval for the mean function, as well as the median posterior estimate of the mean function. Posterior samples fo the mean function are also returned.
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{k}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time <- seq(0, 990, 10)
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CI for mean function
#' CI <- FMeanCI(dir, n_files, time, basis_degree, boundary_knots, internal_knots, K)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time <- seq(0, 990, 10)
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for mean function
#' CI <- FMeanCI(dir, n_files, time, basis_degree, boundary_knots, internal_knots, K, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time <- seq(0, 990, 10)
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for mean function
#' CI <- FMeanCI(dir, n_files, time, basis_degree, boundary_knots, internal_knots, K, X = X)
#'
#' @export
FMeanCI <- function(dir, n_files, time, basis_degree, boundary_knots, internal_knots, k, alpha = 0.05, rescale = TRUE, simultaneous = FALSE, burnin_prop = 0.1, X = NULL, trans_mats = NULL) {
    .Call('_BayesFMMM_FMeanCI', PACKAGE = 'BayesFMMM', dir, n_files, time, basis_degree, boundary_knots, internal_knots, k, alpha, rescale, simultaneous, burnin_prop, X, trans_mats)
}

#' Calculates the credible interval for the mean (High Dimensional Functional Data)
#'
#' This function calculates a credible interval with the user specified coverage.
#' In order to run this function, the directory of the posterior samples needs
#' to be specified. The function will return the credible intervals and the median
#' posterior estimate of the mean function at the time points specified by the
#' user (\code{time} variable). The user can specify if they would like the algorithm
#' to automatically rescale the parameters for interpretability (suggested). If
#' the user chooses to rescale, then all class memberships will be rescaled so
#' that at least one observation is in only one class. The user can also specify
#' if they want pointwise credible intervals or simultaneous credible intervals.
#' The simultaneous intervals will likely be wider than the pointwise credible
#' intervals.
#'
#' @name HDFMeanCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param k Int containing the cluster group of which you want to get the credible interval for
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param simultaneous Boolean indicating whether or not the credible intervals should be simultaneous credible intervals or pointwise credible intervals
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix containing covariates at points of interest (of dimension W x D (number of points of interest x number of covariates))
#' @return CI list containing the credible interval for the mean function, as well as the median posterior estimate of the mean function. Also returns posterior samples of the mean function.
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{each element must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of corresponding \code{boundary_knots}}
#'   \item{\code{k}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "HDFunctional_trace", package = "BayesFMMM"), "/")
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#' time <- time[[1]]
#' n_files <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Get CI for mean function
#' CI <- HDFMeanCI(dir, n_files, time, basis_degree, boundary_knots, internal_knots, K)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' dir <- paste0(system.file("test-data", "HDFunctional_trace", package = "BayesFMMM"), "/")
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#' time <- time[[1]]
#' n_files <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for mean function
#' CI <- HDFMeanCI(dir, n_files, time, basis_degree, boundary_knots, internal_knots, K, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' dir <- paste0(system.file("test-data", "HDFunctional_trace", package = "BayesFMMM"), "/")
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#' time <- time[[1]]
#' n_files <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for mean function
#' CI <- HDFMeanCI(dir, n_files, time, basis_degree, boundary_knots, internal_knots, K, X = X)
#'
#' @export
HDFMeanCI <- function(dir, n_files, time, basis_degree, boundary_knots, internal_knots, k, alpha = 0.05, rescale = TRUE, simultaneous = FALSE, burnin_prop = 0.1, X = NULL) {
    .Call('_BayesFMMM_HDFMeanCI', PACKAGE = 'BayesFMMM', dir, n_files, time, basis_degree, boundary_knots, internal_knots, k, alpha, rescale, simultaneous, burnin_prop, X)
}

#' Calculates the credible interval for the mean (Multivariate Data)
#'
#' This function calculates a credible interval with the user specified coverage.
#' In order to run this function, the directory of the posterior samples needs
#' to be specified. The function will return the credible intervals and the median
#' posterior estimate of the mean. The user can specify if they would like the
#' algorithm to automatically rescale the parameters for interpretability
#' (suggested). If the user chooses to rescale, then all class memberships will
#' be rescaled so that at least one observation is in only one class.
#'
#' @name MVMeanCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix containing covariates at points of interest (of dimension W x D (number of points of interest x number of covariates))
#' @return CI list containing the credible interval for the mean function, as well as the median posterior estimate of the mean function. Posterior draws of the mean structure are also returned. If covariate adjusted, the third index corresponds number of points of interest
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get CI for mean function
#' CI <- MVMeanCI(dir, n_files)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for mean function
#' CI <- MVMeanCI(dir, n_files, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for mean function
#' CI <- MVMeanCI(dir, n_files, X = X)
#'
#' @export
MVMeanCI <- function(dir, n_files, alpha = 0.05, rescale = TRUE, burnin_prop = 0.1, X = NULL) {
    .Call('_BayesFMMM_MVMeanCI', PACKAGE = 'BayesFMMM', dir, n_files, alpha, rescale, burnin_prop, X)
}

#' Calculates the credible interval for the covariance (Functional Data)
#'
#' This function calculates a credible interval for the covariance function
#' between the l-th and m-th clusters, with the user specified coverage. This
#' function can handle covariate adjusted models, where the mean and covariance
#' functions depend on the covariates of interest. If not covariate adjusted, or
#' if the covariates only influence the mean structure, DO NOT specify \code{X} in
#' this function.
#' In order to run this function, the directory of the posterior samples needs
#' to be specified. The function will return the credible intervals and the median
#' posterior estimate of the covariance function at the time points specified by the
#' user (\code{time} variable). The user can specify if they would like the algorithm
#' to automatically rescale the parameters for interpretability (suggested). If
#' the user chooses to rescale, then all class memberships will be rescaled so
#' that at least one observation is in only one class. The user can also specify
#' if they want pointwise credible intervals or simultaneous credible intervals.
#' The simultaneous intervals will likely be wider than the pointwise credible
#' intervals.
#'
#' @name FCovCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time1 Vector containing time points of interest for first cluster
#' @param time2 Vector containing time points of interest for second cluster
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param simultaneous Boolean indicating whether or not the credible intervals should be simultaneous credible intervals or pointwise credible intervals
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix containing covariates at points of interest (of dimension W x D (number of points of interest x number of covariates))
#' @param trans_mats Matrix containing transformations of the variables to help with identifiability when K > 2 (of dimension (K x n_iters) x K)
#' @return CI list containing the credible interval for the covariance function, as well as the median posterior estimate of the covariance function. Posterior estimates of the covariance function are also returned.
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_MCMC}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{l}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{m}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time1 <- seq(0, 990, 10)
#' time2 <- seq(0, 990, 10)
#' l <- 1
#' m <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CI for Covaraince function
#' CI <- FCovCI(dir, n_files, time1, time2, basis_degree,
#'              boundary_knots, internal_knots, l, m)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time1 <- seq(0, 990, 10)
#' time2 <- seq(0, 990, 10)
#' l <- 1
#' m <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CI for Covaraince function
#' CI <- FCovCI(dir, n_files, time1, time2, basis_degree,
#'              boundary_knots, internal_knots, l, m)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time1 <- seq(0, 990, 10)
#' time2 <- seq(0, 990, 10)
#' l <- 1
#' m <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for Covaraince function
#' CI <- FCovCI(dir, n_files, time1, time2, basis_degree,
#'              boundary_knots, internal_knots, l, m, X = X)
#'
#'
#' @export
FCovCI <- function(dir, n_files, time1, time2, basis_degree, boundary_knots, internal_knots, l, m, alpha = 0.05, rescale = TRUE, simultaneous = FALSE, burnin_prop = 0.1, X = NULL, trans_mats = NULL) {
    .Call('_BayesFMMM_FCovCI', PACKAGE = 'BayesFMMM', dir, n_files, time1, time2, basis_degree, boundary_knots, internal_knots, l, m, alpha, rescale, simultaneous, burnin_prop, X, trans_mats)
}

#' Calculates the credible interval for the covariance (High Dimensional Functional Data)
#'
#' This function calculates a credible interval for the covariance function
#' between the l-th and m-th clusters, with the user specified coverage. This
#' function can handle covariate adjusted models, where the mean and covariance
#' functions depend on the covariates of interest. If not covariate adjusted, or
#' if the covariates only influence the mean structure, DO NOT specify \code{X} in
#' this function.
#' In order to run this function, the directory of the posterior samples needs
#' to be specified. The function will return the credible intervals and the median
#' posterior estimate of the covariance function at the time points specified by the
#' user (\code{time} variable). The user can specify if they would like the algorithm
#' to automatically rescale the parameters for interpretability (suggested). If
#' the user chooses to rescale, then all class memberships will be rescaled so
#' that at least one observation is in only one class. The user can also specify
#' if they want pointwise credible intervals or simultaneous credible intervals.
#' The simultaneous intervals will likely be wider than the pointwise credible
#' intervals.
#'
#' @name HDFCovCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time1 Vector containing time points of interest for first cluster
#' @param time2 Vector containing time points of interest for second cluster
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param simultaneous Boolean indicating whether or not the credible intervals should be simultaneous credible intervals or pointwise credible intervals
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix containing covariates at points of interest (of dimension W x D (number of points of interest x number of covariates))
#' @return CI list containing the credible interval for the covariance function, as well as the median posterior estimate of the covariance function. Posterior estimates of the covariance function are also returned.
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_MCMC}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{l}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{m}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "HDFunctional_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' n_MCMC <- 200
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#' time <- time[[1]]
#' time1 <- time
#' time2 <- time
#' l <- 1
#' m <- 1
#' basis_degree <- c(2,2)
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Get CI for Covaraince function
#' CI <- HDFCovCI(dir, n_files, time1, time2, basis_degree,
#'              boundary_knots, internal_knots, l, m)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "HDFunctional_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' n_MCMC <- 200
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#' time <- time[[1]]
#' time1 <- time
#' time2 <- time
#' l <- 1
#' m <- 1
#' basis_degree <- c(2,2)
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Get CI for Covaraince function
#' CI <- HDFCovCI(dir, n_files, time1, time2, basis_degree,
#'              boundary_knots, internal_knots, l, m)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "HDFunctional_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' n_MCMC <- 200
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#' time <- time[[1]]
#' time1 <- time
#' time2 <- time
#' l <- 1
#' m <- 1
#' basis_degree <- c(2,2)
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for Covaraince function
#' CI <- HDFCovCI(dir, n_files, time1, time2, basis_degree,
#'              boundary_knots, internal_knots, l, m, X = X)
#'
#' @export
HDFCovCI <- function(dir, n_files, time1, time2, basis_degree, boundary_knots, internal_knots, l, m, alpha = 0.05, rescale = TRUE, simultaneous = FALSE, burnin_prop = 0.1, X = NULL) {
    .Call('_BayesFMMM_HDFCovCI', PACKAGE = 'BayesFMMM', dir, n_files, time1, time2, basis_degree, boundary_knots, internal_knots, l, m, alpha, rescale, simultaneous, burnin_prop, X)
}

#' Calculates the credible interval for the covariance (Multivariate Data)
#'
#' This function calculates a credible interval for the covariance matrix
#' between the l-th and m-th clusters, with the user specified coverage. This
#' function can handle covariate adjusted models, where the mean and covariance
#' functions depend on the covariates of interest. If not covariate adjusted, or
#' if the covariates only influence the mean structure, DO NOT specify \code{X} in
#' this function.
#' In order to run this function, the directory of the posterior samples needs
#' to be specified. The function will return the credible intervals and the median
#' posterior estimate of the mean. The user can specify if they would like the
#' algorithm to automatically rescale the parameters for interpretability
#' (suggested). If the user chooses to rescale, then all class memberships will
#' be rescaled so that at least one observation is in only one class.
#'
#' @name MVCovCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix containing covariates at points of interest (of dimension W x D (number of points of interest x number of covariates))
#' @return CI list containing the credible interval for the mean function, as well as the median posterior estimate of the mean function. Posterior estimates of the covariance function are also returned.
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_MCMC}}{must be an integer larger than or equal to 1}
#'   \item{\code{l}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{m}}{must be an integer larger than 1 and less than or equal to the number of clusters in the model}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' l <- 1
#' m <- 1
#'
#' ## Get CI for cov function
#' CI <- MVCovCI(dir, n_files, l, m)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' l <- 1
#' m <- 1
#'
#' ## Get CI for cov function
#' CI <- MVCovCI(dir, n_files, l, m)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#' l <- 1
#' m <- 1
#' X <- matrix(seq(-2, 2, 0.2), ncol = 1)
#'
#' ## Get CI for cov function
#' CI <- MVCovCI(dir, n_files, l, m, X = X)
#'
#' @export
MVCovCI <- function(dir, n_files, l, m, alpha = 0.05, rescale = TRUE, burnin_prop = 0.1, X = NULL) {
    .Call('_BayesFMMM_MVCovCI', PACKAGE = 'BayesFMMM', dir, n_files, l, m, alpha, rescale, burnin_prop, X)
}

#' Calculates the credible interval for sigma squared for all types of data
#'
#' @name SigmaCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Integer containing the number of MCMC files
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @returns CI list containing the credible interval for the covariance function, as well as the median posterior estimate of the covariance function
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{alpha}}{must be between 0 and 1}
#' }
#'
#' @examples
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get CI for Z
#' CI <- SigmaCI(dir, n_files)
#'
#' @export
SigmaCI <- function(dir, n_files, alpha = 0.05, burnin_prop = 0.1) {
    .Call('_BayesFMMM_SigmaCI', PACKAGE = 'BayesFMMM', dir, n_files, alpha, burnin_prop)
}

#' Calculates the credible interval for membership parameters Z
#'
#' This function constructs credible intervals using the MCMC samples of the
#' parameters. This function will handle high dimensional functional data,
#' functional data, and multivariate data.
#'
#' @name ZCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Integer containing the number of files per parameter
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param rescale Boolean indicating whether or not we should rescale the Z variables so that there is at least one observation almost completely in one group
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @return CI List containing the desired credible values
#'
#' @examples
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get CI for Z
#' CI <- ZCI(dir, n_files)
#'
#' @export
ZCI <- function(dir, n_files, alpha = 0.05, rescale = TRUE, burnin_prop = 0.1) {
    .Call('_BayesFMMM_ZCI', PACKAGE = 'BayesFMMM', dir, n_files, alpha, rescale, burnin_prop)
}

#' Calculates the DIC of a functional model
#'
#' @name FDIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param cov_adj Boolean containing whether or not the covariance structure depends on the covariates of interest
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#'
#' @returns DIC Double containing DIC value
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed Data and corresponding time points
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#'
#' ## Get DIC
#' DIC <- FDIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get DIC
#' DIC <- FDIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time,
#'             Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get DIC
#' DIC <- FDIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time,
#'             Y, X = X, cov_adj = TRUE)
#'
#' @export
FDIC <- function(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_FDIC', PACKAGE = 'BayesFMMM', dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop, X, cov_adj)
}

#' Calculates the AIC of a functional model
#'
#' @name FAIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param cov_adj Boolean containing whether or not the covariance structure depends on the covariates of interest
#'
#' @returns AIC Double containing AIC value
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed Data and corresponding time points
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#'
#' ## Get AIC
#' AIC <- FAIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get AIC
#' AIC <- FAIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time,
#'             Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get AIC
#' AIC <- FAIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time,
#'             Y, X = X, cov_adj = TRUE)
#'
#' @export
FAIC <- function(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_FAIC', PACKAGE = 'BayesFMMM', dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop, X, cov_adj)
}

#' Calculates the BIC of a functional model
#'
#' @name FBIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param cov_adj Boolean containing whether or not the covariance structure depends on the covariates of interest
#'
#' @returns BIC Double containing BIC value
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed Data and corresponding time points
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#'
#' ## Get BIC
#' BIC <- FBIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get BIC
#' BIC <- FBIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time,
#'             Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Hyperparameters
#' n_files <- 1
#' K <- 2
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get BIC
#' BIC <- FBIC(dir, n_files, basis_degree, boundary_knots, internal_knots, time,
#'             Y, X = X, cov_adj = TRUE)
#'
#' @export
FBIC <- function(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_FBIC', PACKAGE = 'BayesFMMM', dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop, X, cov_adj)
}

#' Calculates the Log-Likelihood of a Functional Model
#'
#' Calculates the log-likelihood of the parameters for each iteration for functional models.
#' This function can handle covariate adjusted models as well as non-adjusted models.
#'
#' @name FLLik
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @param X Matrix of covariates (each row contains the covariates for a single observation) (optional arugment)
#' @param cov_adj Boolean containing whether the model fit had a covariance structure that is covariate-dependent (optional argument)
#' @returns LLik Vector containing the log-likelihood evaluated at each iteration
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed Data and corresponding time points
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Set Hyperparameters
#' n_files <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CI for mean function
#' LL <- FLLik(dir, n_files, basis_degree, boundary_knots, internal_knots,
#'             time, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40), ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Set Hyperparameters
#' n_files <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CI for mean function
#' LL <- FLLik(dir, n_files, basis_degree, boundary_knots, internal_knots,
#'             time, Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40), ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Set Hyperparameters
#' n_files <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#'
#' ## Get CI for mean function
#' LL <- FLLik(dir, n_files, basis_degree, boundary_knots, internal_knots,
#'             time, Y, X = X, cov_adj = TRUE)
#' @export
FLLik <- function(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_FLLik', PACKAGE = 'BayesFMMM', dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, X, cov_adj)
}

#' Calculates the AIC of a multivariate model
#'
#' @name MVAIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param cov_adj Boolean containing whether or not the covariance structure depends on the covariates of interest
#' @returns AIC Double containing AIC value
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get AIC
#' AIC <- MVAIC(dir, n_files, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get AIC
#' AIC <- MVAIC(dir, n_files, Y,  X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get AIC
#' AIC <- MVAIC(dir, n_files, Y, X = X, cov_adj = TRUE)
#'
#' @export
MVAIC <- function(dir, n_files, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_MVAIC', PACKAGE = 'BayesFMMM', dir, n_files, Y, burnin_prop, X, cov_adj)
}

#' Calculates the BIC of a multivariate model
#'
#' @name MVBIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param cov_adj Boolean containing whether or not the covariance structure depends on the covariates of interest
#' @returns BIC Double containing BIC value
#'
#' @examples
#'
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get BIC
#' BIC <- MVBIC(dir, n_files, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get BIC
#' BIC <- MVBIC(dir, n_files, Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get BIC
#' BIC <- MVBIC(dir, n_files, Y, X = X, cov_adj = TRUE)
#'
#' @export
MVBIC <- function(dir, n_files, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_MVBIC', PACKAGE = 'BayesFMMM', dir, n_files, Y, burnin_prop, X, cov_adj)
}

#' Calculates the DIC of a multivariate model
#'
#' @name MVDIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param cov_adj Boolean containing whether or not the covariance structure depends on the covariates of interest
#' @returns DIC Double containing DIC value
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get DIC
#' DIC <- MVDIC(dir, n_files, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get DIC
#' DIC <- MVDIC(dir, n_files, Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get DIC
#' DIC <- MVDIC(dir, n_files, Y, X = X, cov_adj = TRUE)
#'
#' @export
MVDIC <- function(dir, n_files, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_MVDIC', PACKAGE = 'BayesFMMM', dir, n_files, Y, burnin_prop, X, cov_adj)
}

#' Calculates the Log-Likelihood of a Multivariate Model
#'
#' Calculates the log-likelihood of the parameters for each iteration of a multivariate model.
#' This function can handle covariate adjusted models as well as non-adjusted models.
#'
#'
#' @name MVLLik
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param X Matrix of covariates (each row contains the covariates for a single observation) (optional arugment)
#' @param cov_adj Boolean containing whether the model fit had a covariance structure that is covariate-dependent (optional argument)
#' @returns LLik Vector containing the log-likelihood evaluated at each iteration
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get log likelihood
#' LL <- MVLLik(dir, n_files, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get log likelihood
#' LL <- MVLLik(dir, n_files, Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed data and observed covariates
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Multivariate_trace", package = "BayesFMMM"), "/")
#' n_files <- 1
#'
#' ## Get log likelihood
#' LL <- MVLLik(dir, n_files, Y, X = X, cov_adj = TRUE)
#'
#' @export
MVLLik <- function(dir, n_files, Y, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_MVLLik', PACKAGE = 'BayesFMMM', dir, n_files, Y, X, cov_adj)
}

#' Conditional Predictive Ordinates
#'
#' Calculates the Conditional Predictive Ordinates for functional models.
#' This function can handle covariate adjusted models as well as non-adjusted models.
#'
#' @name ConditionalPredictiveOrdinates
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param X Matrix of covariates (each row contains the covariates for a single observation) (optional arugment)
#' @param cov_adj Boolean containing whether the model fit had a covariance structure that is covariate-dependent (optional argument)
#' @param log_CPO Boolean conatining whether or not CPO is returned on the log scale (optional argument)
#' @returns CPO Vector containing the CPO for each observation
#'
#' //' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Observed Data and corresponding time points
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Set Hyperparameters
#' n_files <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CPO
#' CPO <- ConditionalPredictiveOrdinates(dir, n_files, basis_degree, boundary_knots,
#'                                       internal_knots, time, Y)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Observed Data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40), ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Set Hyperparameters
#' n_files <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CPO
#' CPO <- ConditionalPredictiveOrdinates(dir, n_files, basis_degree, boundary_knots,
#'                                       internal_knots, time, Y, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Observed Data, corresponding time points, and observed covariates
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' X <- matrix(rnorm(40), ncol = 1)
#'
#' ## Directory of saved MCMC iterations
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#'
#' ## Set Hyperparameters
#' n_files <- 1
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CPO
#' CPO <- ConditionalPredictiveOrdinates(dir, n_files, basis_degree, boundary_knots,
#'                                       internal_knots, time, Y, X = X,
#'                                       cov_adj = TRUE)
#'
#' @export
ConditionalPredictiveOrdinates <- function(dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop = 0.1, X = NULL, cov_adj = FALSE, log_CPO = TRUE) {
    .Call('_BayesFMMM_ConditionalPredictiveOrdinates', PACKAGE = 'BayesFMMM', dir, n_files, basis_degree, boundary_knots, internal_knots, time, Y, burnin_prop, X, cov_adj, log_CPO)
}

#' Estimated Sample Paths
#'
#' Calculates CIs for the estimated sample paths of the observed data for posterior
#' predictive checks.
#'
#' @name FSamplePaths
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param basis_degree Int containing the degree of B-splines used
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param time Field of vectors containing time points at which the function was observed
#' @param alpha Double specifying the percentile of the credible interval ((1 - alpha) * 100 percent)
#' @param burnin_prop Double containing proportion of MCMC samples to discard
#' @param simultaneous Boolean indicating whether or not the credible intervals should be simultaneous credible intervals or pointwise credible intervals
#' @param X Matrix of covariates (each row contains the covariates for a single observation) (optional arugment)
#' @param cov_adj Boolean containing whether the model fit had a covariance structure that is covariate-dependent (optional argument)
#' @returns CPO Vector containing the CPO for each observation
#'
#' //' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{n_files}}{must be an integer larger than or equal to 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{alpha}}{must be between 0 and 1}
#'   \item{\code{burnin_prop}}{must be less than 1 and greater than or equal to 0}
#'   \item{\code{X}}{must have the same number of columns as covariates in the model (D)}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Set Hyperparameters
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get CI for Sample Paths
#' CI <- FSamplePaths(dir, n_files, basis_degree, boundary_knots, internal_knots, time)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#' X <- matrix(rnorm(40), ncol = 1)
#'
#' ## Get CI for Sample Paths
#' CI <- FSamplePaths(dir, n_files, basis_degree, boundary_knots,
#'                    internal_knots, time, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' dir <- paste0(system.file("test-data", "Functional_trace", package = "BayesFMMM"),"/")
#' n_files <- 1
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#' basis_degree <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#' X <- matrix(rnorm(40), ncol = 1)
#'
#' ## Get CI for Sample Paths
#' CI <- FSamplePaths(dir, n_files, basis_degree, boundary_knots,
#'                    internal_knots, time, X = X, cov_adj = TRUE)
#'
#' @export
FSamplePaths <- function(dir, n_files, basis_degree, boundary_knots, internal_knots, time, alpha = 0.05, burnin_prop = 0.1, simultaneous = FALSE, X = NULL, cov_adj = FALSE) {
    .Call('_BayesFMMM_FSamplePaths', PACKAGE = 'BayesFMMM', dir, n_files, basis_degree, boundary_knots, internal_knots, time, alpha, burnin_prop, simultaneous, X, cov_adj)
}

#' Find initial starting position for mean and allocation structure for functional data
#'
#' Function for finding a good initial starting point for nu parameters, Z, and
#' eta (if covariate adjusted)
#' parameters for functional data, with option for tempered transitions. This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BFMMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param K Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{eta}}{Eta samples from the chain with the highest average log-likelihood (if covariate adjusted)}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma_sq}}{sigma_sq samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau_eta}}{Tau_Eta samples from the chain with the highest average log-likelihood (if covariate adjusted)}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' //' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{X}}{must have n_funct number of rows (if specified)}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Run function
#' x <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                              basis_degree, n_eigen, boundary_knots,
#'                              internal_knots)
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, X = X)
#'
#' @export
BFMMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, X = NULL, c = NULL, b = 10, alpha1l = 1, alpha2l = 2, beta1l = 1, beta2l = 1, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFMMM_BFMMM_Nu_Z_multiple_try', PACKAGE = 'BayesFMMM', tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, X, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0)
}

#' Find initial starting points for covariance parameters given mean and allocation structure for functional data
#'
#' This function is meant to be used after using \code{BFMMM_NU_Z_multiple_try}.
#' This function samples from the rest of the model parameters given a fixed value of
#' nu and Z. The fixed value of nu, Z, and eta (if covariate adjusted) are found by using the best markov chain
#' found in \code{BFMMM_NU_Z_multiple_try}. Once this function is ran, the results
#' can be used in \code{BFMMM_warm_start}. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BFMMM_Theta_est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param n_try Int containing how many different chains are tried
#' @param K Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param multiple_try List containing results from \code{BFMMM_Nu_Z_multiple_try}
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @param covariance_adj Boolean containing whether or not covariates should affect the covariance
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{Z}}{estimates of Z}
#'   \item{\code{nu}}{estimates of nu}
#'   \item{\code{eta}}{estimated value from \code{BFMMM_Nu_Z_multiple_try} (if covariate adjusted)}
#'   \item{\code{chi}}{chi samples from MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{A_xi}}{A_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{delta}}{delta samples from MCMC chain}
#'   \item{\code{delta_xi}}{delta_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{gamma_xi}}{gamma_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{sigma_sq}}{sigma_sq samples from MCMC chain}
#'   \item{\code{tau}}{tau samples from MCMC chain}
#'   \item{\code{tau_eta}}{tau_eta samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{X}}{must have n_funct number of rows (if specified)}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots)
#'
#' ## Run function
#' est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1, X = X, covariance_adj = TRUE)
#'
#' @export
BFMMM_Theta_est <- function(tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, X = NULL, burnin_prop = 0.8, c = NULL, b = 10, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 2, beta2l = 2, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1, covariance_adj = FALSE) {
    .Call('_BayesFMMM_BFMMM_Theta_est', PACKAGE = 'BayesFMMM', tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, X, burnin_prop, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0, covariance_adj)
}

#' Performs MCMC for functional models given an informed set of starting points
#'
#' This function is meant to be used after using \code{BFMMM_Nu_Z_multiple_try}
#' and \code{BFMMM_Theta_est}. This function will use the outputs of these two
#' functions to start the MCMC chain in a good location. Since the posterior distribution
#' can often be multimodal, it is important to have a good starting position.
#' To help move across modes, this function allows users to use tempered transitions
#' every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
#' and un-tempered transitions, we can allow the chain to explore multiple modes without
#' while keeping sampling relatively computationally efficient. To save on RAM usage, we
#' allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
#' If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
#' of the chain is stored in the user specified directory (\code{dir}). The samples from each
#' parameter can be viewed using the following functions: \code{ReadFieldCube},
#' \code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
#' \code{ReadVec}. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BFMMM_warm_start
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param K Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param multiple_try List containing results from \code{BFMMM_Nu_Z_multiple_try}
#' @param theta_est List containing results from \code{BFMMM_Theta_est}
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param dir String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)
#' @param thinning_num Int containing how often we should save MCMC iterations
#' @param beta_N_t Double containing the maximum weight for tempered transitions
#' @param N_t Int containing total number of tempered transitions
#' @param n_temp_trans Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)
#' @param r_stored_iters Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @param covariance_adj Boolean containing whether or not the covariance structure should depend on the covariates
#'
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the MCMC chain}
#'   \item{\code{chi}}{chi samples from the MCMC chain}
#'   \item{\code{pi}}{pi samples from the MCMC chain}
#'   \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from the MCMC chain}
#'   \item{\code{sigma_sq}}{sigma_sq samples from the MCMC chain}
#'   \item{\code{tau}}{tau samples from the MCMC chain}
#'   \item{\code{tau_eta}}{tau_eta samples from the MCMC chain (if covariate adjusted)}
#'   \item{\code{eta}}{eta samples from the MCMC chain (if covariate adjusted)}
#'   \item{\code{xi}}{xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{delta_xi}}{delta_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{gamma_xi}}{gamma_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{A_xi}}{A_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from the MCMC chain}
#'   \item{\code{Z}}{Z samples from the MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{X}}{ must have n_funct number of rows}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{X}}{must have n_funct number of rows (if specified)}
#'   \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
#'   \item{\code{n_thinning}}{must be a positive integer}
#'   \item{\code{beta_N_t}}{must be between 1 and 0}
#'   \item{\code{N_t}}{must be a positive integer}
#'   \item{\code{n_temp_trans}}{must be a non-negative integer}
#'   \item{\code{r_stored_iters}}{must be a non-negative integer}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#'@examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots)
#'
#' ## Run function
#' est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
#'                                basis_degree, n_eigen, boundary_knots,
#'                                internal_knots, est1, est2)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1, X = X)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
#'                                basis_degree, n_eigen, boundary_knots,
#'                                internal_knots, est1, est2, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1, X = X, covariance_adj = TRUE)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
#'                                basis_degree, n_eigen, boundary_knots,
#'                                internal_knots, est1, est2, X = X, covariance_adj = TRUE)
#' @export
BFMMM_warm_start <- function(tot_mcmc_iters, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, theta_est, X = NULL, burnin_prop = 0.8, dir = NULL, thinning_num = 1, beta_N_t = 1, N_t = 1L, n_temp_trans = 0L, r_stored_iters = 0L, c = NULL, b = 10, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 2, beta2l = 2, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1, covariance_adj = FALSE) {
    .Call('_BayesFMMM_BFMMM_warm_start', PACKAGE = 'BayesFMMM', tot_mcmc_iters, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, theta_est, X, burnin_prop, dir, thinning_num, beta_N_t, N_t, n_temp_trans, r_stored_iters, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0, covariance_adj)
}

#' Reads saved parameter data (sigma_sq, alpha_3)
#'
#' Reads armadillo vector type data and returns it as a vector in R. The following
#' parameters can be read in using this function: sigma_sq and alpha_3.
#'
#' @name ReadVec
#' @param file String containing location where armadillo vector is stored
#' @returns Vec Vector containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "sigma.txt", package = "BayesFMMM")
#'
#' ## Read in file
#' sigma_sq <- ReadVec(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set directory
#' # dir <- "~/sigma"
#' #
#' ## initialize placeholder
#' # sigma_sq <- rep(0, n_files * n_samp)
#' # for(i in 0:(n_files - 1)){
#' #   sigma_i <- ReadVec(paste(dir, as.character(i),".txt", sep = ""))
#' #   sigma_sq[((n_samp * i) + 1):(n_samp * (i+1))] <- sigma_i
#' #}
#' #############################################################
#'
#' @export
ReadVec <- function(file) {
    .Call('_BayesFMMM_ReadVec', PACKAGE = 'BayesFMMM', file)
}

#' Reads saved parameter data (pi, A, delta, tau)
#'
#' Reads armadillo matrix type data and returns it as a matirx in R. The following
#' parameters can be read in using this function: pi, A, delta, and tau.
#'
#' @name ReadMat
#' @param file String containing location where armadillo matrix is stored
#' @returns Mat Matrix containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "pi.txt", package = "BayesFMMM")
#'
#' ## Read in file
#' pi <- ReadMat(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set dim of parameter
#' # dim <- 3
#' #
#' ## Set directory
#' # dir <- "~/pi"
#' #
#' ## initialize placeholder
#' # pi <- mat(0, dim, n_files * n_samp)
#' # for(i in 0:(n_files - 1)){
#' #   pi_i <- ReadMat(paste(dir, as.character(i),".txt", sep = ""))
#' #   pi[,((n_samp * i) + 1):(n_samp * (i+1))] <- pi_i
#' #}
#' #############################################################
#'
#' @export
ReadMat <- function(file) {
    .Call('_BayesFMMM_ReadMat', PACKAGE = 'BayesFMMM', file)
}

#' Reads saved parameter data (nu, chi, Z)
#'
#' Reads armadillo cube type data and returns it as an array in R. The following
#' parameters can be read in using this function: nu, chi, and Z.
#'
#' @name ReadCube
#' @param file String containing location where armadillo cube is stored
#' @returns Cube Array containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "nu.txt", package = "BayesFMMM")
#'
#' ## Read in file
#' nu <- ReadCube(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set dim of parameter
#' # dim1 <- 3
#' # dim2 <- 8
#' #
#' ## Set directory
#' # dir <- "~/Nu"
#' #
#' ## initialize placeholder
#' # nu <- array(0, dim = c(dim1, dim2, n_files * n_samp))
#' # for(i in 0:(n_files - 1)){
#' #   nu_i <- ReadCube(paste(dir, as.character(i),".txt", sep = ""))
#' #   nu[,,((n_samp * i) + 1):(n_samp * (i+1))] <- nu_i
#' #}
#' #############################################################
#'
#' @export
ReadCube <- function(file) {
    .Call('_BayesFMMM_ReadCube', PACKAGE = 'BayesFMMM', file)
}

#' Reads saved parameter data (gamma, Phi)
#'
#' Reads armadillo field of cubes type data and returns it as a list of arrays
#' in R. The following parameters can be read in using this function: gamma and
#' Phi.
#'
#' @name ReadFieldCube
#' @param file String containing location where armadillo field of cubes is stored
#' @returns FieldCube List of arrays containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "Phi.txt", package = "BayesFMMM")
#'
#' ## Read in file
#' Phi <- ReadFieldCube(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set dim of parameter
#' # dim1 <- 3
#' # dim2 <- 8
#' # dim3 <- 2
#' #
#' ## Set directory
#' # dir <- "~/Phi"
#' #
#' ## initialize placeholder
#' # Phi <- array(0, dim = c(dim1, dim2, dim3, n_files * n_samp))
#' # for(i in 0:(n_files - 1)){
#' #   Phi_i <- ReadFieldCube(paste(dir, as.character(i),".txt", sep = ""))
#' #   Phi[,,((n_samp * i) + 1):(n_samp * (i+1))] <- Phi_i
#' #}
#' #############################################################
#'
#' @export
ReadFieldCube <- function(file) {
    .Call('_BayesFMMM_ReadFieldCube', PACKAGE = 'BayesFMMM', file)
}

#' Reads saved armadillo data
#'
#' Reads armadillo field of matrices type data and returns it as a list of matrices
#' in R.
#'
#' @name ReadFieldMat
#' @param file String containing location where armadillo field of matrices is stored
#' @returns FieldMatrix List of matrices containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "fieldmat.txt", package = "BayesFMMM")
#'
#' ## Read in file
#' samp_data <- ReadFieldMat(file)
#'
#' @export
ReadFieldMat <- function(file) {
    .Call('_BayesFMMM_ReadFieldMat', PACKAGE = 'BayesFMMM', file)
}

#' Reads saved armadillo data
#'
#' Reads armadillo field of vectors type data and returns it as a list of vectors
#' in R.
#'
#' @name ReadFieldVec
#' @param file String containing location where armadillo field of vectors is stored
#' @returns FieldVec List of vectors containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "fieldvec.txt", package = "BayesFMMM")
#'
#' ## Read in file
#' samp_data <- ReadFieldVec(file)
#'
#' @export
ReadFieldVec <- function(file) {
    .Call('_BayesFMMM_ReadFieldVec', PACKAGE = 'BayesFMMM', file)
}

#' Find initial starting position for mean and allocation parameters for high dimensional functional data (Domain dimension > 1)
#'
#' Function for finding a good initial starting point for nu parameters, Z
#' parameters, and eta parameters (if covariates are included) for functional
#' data, with option for tempered transitions. This
#' function was constructed to handle data in which the domain has dimension
#' greater than 1 (i.e. a surface or higher dimensional function). This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BHDFMMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param K Int containing the number of clusters
#' @param Y List of vectors containing the observed values (flattened)
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{eta}}{Eta samples from the chain with the highest average log-likelihood (if covariate adjusted)}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma_sq}}{sigma_sq samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau_eta}}{Tau_Eta samples from the chain with the highest average log-likelihood (if covariate adjusted)}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{each element must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of corresponding \code{boundary_knots}}
#'   \item{\code{X}}{must have n_funct number of rows (if specified)}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Run function
#' x <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                basis_degree, n_eigen, boundary_knots,
#'                                internal_knots)
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots, X = X)
#'
#' @export
BHDFMMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, X = NULL, c = NULL, b = 10, alpha1l = 1, alpha2l = 2, beta1l = 1, beta2l = 1, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFMMM_BHDFMMM_Nu_Z_multiple_try', PACKAGE = 'BayesFMMM', tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, X, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0)
}

#' Find initial starting points for the covariance structure for high dimensional functional data (Domain dimension > 1)
#'
#' This function is meant to be used after using \code{BHDFMMM_NU_Z_multiple_try}.
#' This function samples from the rest of the model parameters given a fixed value of
#' nu and Z. The fixed value of nu and Z are found by using the best markov chain
#' found in \code{BHDFMMM_NU_Z_multiple_try}. Once this function is ran, the results
#' can be used in \code{BHDFMMM_warm_start}. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BHDFMMM_Theta_est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param n_try Int containing how many different chains are tried
#' @param K Int containing the number of clusters
#' @param Y List of vectors containing the observed values (flattened)
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param multiple_try List containing results from \code{BHDFMMM_Nu_Z_multiple_try}
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @param covariance_adj Boolean containing whether or not covariates should affect the covariance
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{Z}}{estimates of Z}
#'   \item{\code{nu}}{estimates of nu}
#'   \item{\code{eta}}{estimated value from \code{BHDFMMM_Nu_Z_multiple_try} (if covariate adjusted)}
#'   \item{\code{chi}}{chi samples from MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{A_xi}}{A_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{delta}}{delta samples from MCMC chain}
#'   \item{\code{delta_xi}}{delta_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{gamma_xi}}{gamma_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{sigma_sq}}{sigma_sq samples from MCMC chain}
#'   \item{\code{tau}}{tau samples from MCMC chain}
#'   \item{\code{tau_eta}}{tau_eta samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{X}}{must have n_funct number of rows (if specified)}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Run function
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots)
#'
#' ## Run function
#' est2 <- BHDFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                           basis_degree, n_eigen, boundary_knots,
#'                           internal_knots, est1)
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BHDFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BHDFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                           basis_degree, n_eigen, boundary_knots,
#'                           internal_knots, est1, X = X, covariance_adj = TRUE)
#' @export
BHDFMMM_Theta_est <- function(tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, X = NULL, burnin_prop = 0.8, c = NULL, b = 10, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 2, beta2l = 2, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1, covariance_adj = FALSE) {
    .Call('_BayesFMMM_BHDFMMM_Theta_est', PACKAGE = 'BayesFMMM', tot_mcmc_iters, n_try, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, X, burnin_prop, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0, covariance_adj)
}

#' Performs MCMC for high dimensional functional model given an informed set of starting points
#'
#' This function is meant to be used after using \code{BHDFMMM_Nu_Z_multiple_try}
#' and \code{BHDFMMM_Theta_est}. This function will use the outputs of these two
#' functions to start the MCMC chain in a good location. Since the posterior distribution
#' can often be multimodal, it is important to have a good starting position.
#' To help move across modes, this function allows users to use tempered transitions
#' every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
#' and un-tempered transitions, we can allow the chain to explore multiple modes without
#' while keeping sampling relatively computationally efficient. To save on RAM usage, we
#' allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
#' If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
#' of the chain is stored in the user specified directory (\code{dir}). The samples from each
#' parameter can be viewed using the following functions: \code{ReadFieldCube},
#' \code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
#' \code{ReadVec}. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BHDFMMM_warm_start
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param K Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param multiple_try List containing results from \code{BFMMM_Nu_Z_multiple_try}
#' @param theta_est List containing results from \code{BFMMM_Theta_est}
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param dir String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)
#' @param thinning_num Int containing how often we should save MCMC iterations
#' @param beta_N_t Double containing the maximum weight for tempered transitions
#' @param N_t Int containing total number of tempered transitions
#' @param n_temp_trans Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)
#' @param r_stored_iters Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @param covariance_adj Boolean containing whether or not the covariance structure should depend on the covariates
#'
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the MCMC chain}
#'   \item{\code{chi}}{chi samples from the MCMC chain}
#'   \item{\code{pi}}{pi samples from the MCMC chain}
#'   \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from the MCMC chain}
#'   \item{\code{sigma_sq}}{sigma_sq samples from the MCMC chain}
#'   \item{\code{tau}}{tau samples from the MCMC chain}
#'   \item{\code{tau_eta}}{tau_eta samples from the MCMC chain (if covariate adjusted)}
#'   \item{\code{eta}}{eta samples from the MCMC chain (if covariate adjusted)}
#'   \item{\code{xi}}{xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{delta_xi}}{delta_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{gamma_xi}}{gamma_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{A_xi}}{A_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from the MCMC chain}
#'   \item{\code{Z}}{Z samples from the MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{X}}{ must have n_funct number of rows}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
#'   \item{\code{n_thinning}}{must be a positive integer}
#'   \item{\code{beta_N_t}}{must be between 1 and 0}
#'   \item{\code{N_t}}{must be a positive integer}
#'   \item{\code{n_temp_trans}}{must be a non-negative integer}
#'   \item{\code{r_stored_iters}}{must be a non-negative integer}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#'@examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Run function
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots)
#'
#' ## Run function
#' est2 <- BHDFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                           basis_degree, n_eigen, boundary_knots,
#'                           internal_knots, est1)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BHDFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
#'                                  basis_degree, n_eigen, boundary_knots,
#'                                  internal_knots, est1, est2)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BHDFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1, X = X)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BHDFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
#'                                  basis_degree, n_eigen, boundary_knots,
#'                                  internal_knots, est1, est2, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFMMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BHDFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots, X = X)
#'
#' ## Run function
#' est2 <- BHDFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
#'                           basis_degree, n_eigen, boundary_knots,
#'                           internal_knots, est1, X = X, covariance_adj = TRUE)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BHDFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
#'                                  basis_degree, n_eigen, boundary_knots,
#'                                  internal_knots, est1, est2, X = X, covariance_adj = TRUE)
#'
#' @export
BHDFMMM_warm_start <- function(tot_mcmc_iters, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, theta_est, X = NULL, burnin_prop = 0.8, dir = NULL, thinning_num = 1, beta_N_t = 1, N_t = 1L, n_temp_trans = 0L, r_stored_iters = 0L, c = NULL, b = 10, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 2, beta2l = 2, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1, covariance_adj = FALSE) {
    .Call('_BayesFMMM_BHDFMMM_warm_start', PACKAGE = 'BayesFMMM', tot_mcmc_iters, K, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, multiple_try, theta_est, X, burnin_prop, dir, thinning_num, beta_N_t, N_t, n_temp_trans, r_stored_iters, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0, covariance_adj)
}

#' Find initial starting position for mean and allocation structure for multivariate data
#'
#' Function for finding a good initial starting point for nu parameters, Z, and eta parameters (if covariate adjusted)
#' for multivariate data, with option for tempered transitions.This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations. To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BMVMMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param K Int containing the number of clusters
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param n_eigen Int containing the number of eigenfunctions
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @returns a List containing:
#' \describe{
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{eta}}{Eta samples from the chain with the highest average log-likelihood (if covariate adjusted)}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma_sq}}{sigma_sq samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau_eta}}{Tau_Eta samples from the chain with the highest average log-likelihood (if covariate adjusted)}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{X}}{must have the same number of rows as Y (if specified)}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' ## Run function
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Run function
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Run function
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen, X = X)
#'
#' @export
BMVMMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, K, Y, n_eigen, X = NULL, c = NULL, b = 10, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFMMM_BMVMMM_Nu_Z_multiple_try', PACKAGE = 'BayesFMMM', tot_mcmc_iters, n_try, K, Y, n_eigen, X, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0)
}

#' Find initial starting points for covariance parameters given mean and allocation structure
#' for multivariate data
#'
#' This function is meant to be used after using \code{BMVMMM_NU_Z_multiple_try}.
#' This function samples from the rest of the model parameters given a fixed value of
#' nu and Z. The fixed value of nu and Z are found by using the best markov chain
#' found in \code{BMVMMM_NU_Z_multiple_try}. Once this function is ran, the results
#' can be used in \code{BMVMMM_warm_start}.To specify a covariate
#' adjusted model, please provide the design matrix X.
#'
#' @name BMVMMM_Theta_est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param n_try Int containing how many different chains are tried
#' @param K Int containing the number of clusters
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param n_eigen Int containing the number of eigenfunctions
#' @param multiple_try List containing results from \code{BMVMMM_Nu_Z_multiple_try}
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @param covariance_adj Boolean containing whether or not covariates should affect the covariance
#' @returns a List containing:
#' \describe{
#'   \item{\code{Z}}{estimates of Z}
#'   \item{\code{nu}}{estimates of nu}
#'   \item{\code{eta}}{estimated value from \code{BFMMM_Nu_Z_multiple_try} (if covariate adjusted)}
#'   \item{\code{chi}}{chi samples from MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{A_xi}}{A_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{delta}}{delta samples from MCMC chain}
#'   \item{\code{delta_xi}}{delta_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{gamma_xi}}{gamma_xi samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{sigma_sq}}{sigma_sq samples from MCMC chain}
#'   \item{\code{tau}}{tau samples from MCMC chain}
#'   \item{\code{tau_eta}}{tau_eta samples from MCMC chain (if covariate adjusted)}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{X}}{must have the same number of rows as Y (if specified)}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha_nu}}{must be positive}
#'   \item{\code{beta_nu}}{must be positive}
#'   \item{\code{alpha_eta}}{must be positive}
#'   \item{\code{beta_eta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' ## Get Estimates of Z and nu
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen)
#'
#' ## Run function
#' est2 <- BMVMMM_Theta_est(tot_mcmc_iters, n_try, K, Y,
#'                         n_eigen, est1)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen, X = X)
#'
#' ## Run function
#' est2 <- BMVMMM_Theta_est(tot_mcmc_iters, n_try, K, Y,
#'                         n_eigen, est1, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen, X = X)
#'
#' ## Run function
#' est2 <- BMVMMM_Theta_est(tot_mcmc_iters, n_try, K, Y,
#'                         n_eigen, est1, X = X, covariance_adj = TRUE)
#'
#' @export
BMVMMM_Theta_est <- function(tot_mcmc_iters, n_try, K, Y, n_eigen, multiple_try, X = NULL, burnin_prop = 0.8, c = NULL, b = 10, nu_1 = 3, alpha1l = 1, alpha2l = 2, beta1l = 1, beta2l = 1, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1, covariance_adj = FALSE) {
    .Call('_BayesFMMM_BMVMMM_Theta_est', PACKAGE = 'BayesFMMM', tot_mcmc_iters, n_try, K, Y, n_eigen, multiple_try, X, burnin_prop, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0, covariance_adj)
}

#' Performs MCMC for multivariate models given an informed set of starting points
#'
#' This function is meant to be used after using \code{BMVMMM_Nu_Z_multiple_try}
#' and \code{BMVMMM_Theta_est}. This function will use the outputs of these two
#' functions to start the MCMC chain in a good location. Since the posterior distribution
#' can often be multimodal, it is important to have a good starting position.
#' To help move across modes, this function allows users to use tempered transitions
#' every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
#' and un-tempered transitions, we can allow the chain to explore multiple modes without
#' while keeping sampling relatively computationally efficient. To save on RAM usage, we
#' allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
#' If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
#' of the chain is stored in the user specified directory (\code{dir}). The samples from each
#' parameter can be viewed using the following functions: \code{ReadFieldCube},
#' \code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
#' \code{ReadVec}. To specify a covariate adjusted model, please provide the design matrix X.
#'
#' @name BMVMMM_warm_start
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param K Int containing the number of clusters
#' @param Y Matrix of observed vectors (each row is an observation)
#' @param n_eigen Int containing the number of eigenfunctions
#' @param multiple_try List containing results from \code{BMVMMM_Nu_Z_multiple_try}
#' @param theta_est List containing results from \code{BMVMMM_Theta_est}
#' @param X Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param dir String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)
#' @param thinning_num Int containing how often we should save MCMC iterations
#' @param beta_N_t Double containing the maximum weight for tempered transitions
#' @param N_t Int containing total number of tempered transitions
#' @param n_temp_trans Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)
#' @param r_stored_iters Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A (scale)
#' @param beta2l Double containing hyperparameter for sampling from A (scale)
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha_nu Double containing hyperparameter for sampling from tau_nu
#' @param beta_nu Double containing hyperparameter for sampling from tau_nu (scale)
#' @param alpha_eta Double containing hyperparameter for sampling from tau_eta
#' @param beta_eta Double containing hyperparameter for sampling from tau_eta (scale)
#' @param alpha_0 Double containing hyperparameter for sampling from sigma_sq
#' @param beta_0 Double containing hyperparameter for sampling from sigma_sq (scale)
#' @param covariance_adj Boolean containing whether or not the covariance structure should depend on the covariates
#'
#' @returns a List containing:
#' \describe{
#'   \item{\code{nu}}{Nu samples from the MCMC chain}
#'   \item{\code{chi}}{chi samples from the MCMC chain}
#'   \item{\code{pi}}{pi samples from the MCMC chain}
#'   \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from the MCMC chain}
#'   \item{\code{sigma_sq}}{sigma_sq samples from the MCMC chain}
#'   \item{\code{tau}}{tau samples from the MCMC chain}
#'   \item{\code{tau_eta}}{tau_eta samples from the MCMC chain}
#'   \item{\code{eta}}{eta samples from the MCMC chain}
#'   \item{\code{xi}}{xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{delta_xi}}{delta_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{gamma_xi}}{gamma_xi samples from the MCMC chain (if covariance_adj is true)}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from the MCMC chain}
#'   \item{\code{Z}}{Z samples from the MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{X}}{must have the same number of rows as Y}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{K}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
#'   \item{\code{n_thinning}}{must be a positive integer}
#'   \item{\code{beta_N_t}}{must be between 1 and 0}
#'   \item{\code{N_t}}{must be a positive integer}
#'   \item{\code{n_temp_trans}}{must be a non-negative integer}
#'   \item{\code{r_stored_iters}}{must be a non-negative integer}
#'   \item{\code{c}}{must be greater than 0 and have K elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#'@examples
#' #########################
#' ### Not Covariate Adj ###
#' #########################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' ## Get Estimates of Z and nu
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen)
#'
#' ## Run function
#' est2 <- BMVMMM_Theta_est(tot_mcmc_iters, n_try, K, Y,
#'                          n_eigen, est1)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BMVMMM_warm_start(tot_mcmc_iters, K, Y, n_eigen, est1, est2)
#'
#' #####################
#' ### Covariate Adj ###
#' #####################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen, X = X)
#'
#' ## Run function
#' est2 <- BMVMMM_Theta_est(tot_mcmc_iters, n_try, K, Y,
#'                         n_eigen, est1, X = X)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BMVMMM_warm_start(tot_mcmc_iters, K, Y, n_eigen, est1, est2, X = X)
#'
#' #####################################################################
#' ### Covariate Adj  (with Covariate-depenent covariance structure) ###
#' #####################################################################
#'
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFMMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' K <- 2
#' n_eigen <- 2
#'
#' X <- matrix(rnorm(20, 0 , 1), nrow = 20, ncol = 1)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BMVMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, n_eigen, X = X)
#'
#' ## Run function
#' est2 <- BMVMMM_Theta_est(tot_mcmc_iters, n_try, K, Y,
#'                         n_eigen, est1, X = X, covariance_adj = TRUE)
#'
#' ## Run MCMC sampler
#' MCMC.chain <- BMVMMM_warm_start(tot_mcmc_iters, K, Y, n_eigen, est1, est2, X = X,
#'                                covariance_adj = TRUE)
#'
#' @export
BMVMMM_warm_start <- function(tot_mcmc_iters, K, Y, n_eigen, multiple_try, theta_est, X = NULL, burnin_prop = 0.8, dir = NULL, thinning_num = 1, beta_N_t = 1, N_t = 1L, n_temp_trans = 0L, r_stored_iters = 0L, c = NULL, b = 10, nu_1 = 3, alpha1l = 1, alpha2l = 2, beta1l = 1, beta2l = 1, a_Z_PM = 10000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha_nu = 10, beta_nu = 1, alpha_eta = 10, beta_eta = 1, alpha_0 = 1, beta_0 = 1, covariance_adj = FALSE) {
    .Call('_BayesFMMM_BMVMMM_warm_start', PACKAGE = 'BayesFMMM', tot_mcmc_iters, K, Y, n_eigen, multiple_try, theta_est, X, burnin_prop, dir, thinning_num, beta_N_t, N_t, n_temp_trans, r_stored_iters, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha_nu, beta_nu, alpha_eta, beta_eta, alpha_0, beta_0, covariance_adj)
}

