% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{BFMMM_Nu_Z_multiple_try_Cov_Adj}
\alias{BFMMM_Nu_Z_multiple_try_Cov_Adj}
\title{Find initial starting position for nu, Eta, and Z parameters for functional data}
\usage{
BFMMM_Nu_Z_multiple_try_Cov_Adj(
  tot_mcmc_iters,
  n_try,
  k,
  Y,
  time,
  X,
  n_funct,
  basis_degree,
  n_eigen,
  boundary_knots,
  internal_knots,
  c = NULL,
  b = 10,
  alpha1l = 1,
  alpha2l = 2,
  beta1l = 1,
  beta2l = 1,
  a_Z_PM = 10000,
  a_pi_PM = 1000,
  var_alpha3 = 0.05,
  var_epsilon1 = 1,
  var_epsilon2 = 1,
  alpha_nu = 1,
  beta_nu = 10,
  alpha_eta = 1,
  beta_eta = 10,
  alpha_0 = 1,
  beta_0 = 1
)
}
\arguments{
\item{tot_mcmc_iters}{Int containing the number of MCMC iterations per try}

\item{n_try}{Int containing how many different chains are tried}

\item{k}{Int containing the number of clusters}

\item{Y}{List of vectors containing the observed values}

\item{time}{List of vectors containing the observed time points}

\item{X}{Matrix of covariates (each row corresponds to an observation)}

\item{n_funct}{Int containing the number of functions}

\item{basis_degree}{Int containing the degree of B-splines used}

\item{n_eigen}{Int containing the number of eigenfunctions}

\item{boundary_knots}{Vector containing the boundary points of our index domain of interest}

\item{internal_knots}{Vector location of internal knots for B-splines}

\item{c}{Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)}

\item{b}{Double containing hyperparameter for sampling from alpha_3}

\item{alpha1l}{Double containing hyperparameter for sampling from A}

\item{alpha2l}{Double containing hyperparameter for sampling from A}

\item{beta1l}{Double containing hyperparameter for sampling from A (scale)}

\item{beta2l}{Double containing hyperparameter for sampling from A (scale)}

\item{a_Z_PM}{Double containing hyperparameter of the random walk MH for Z parameter}

\item{a_pi_PM}{Double containing hyperparameter of the random walk MH for pi parameter}

\item{var_alpha3}{Double containing variance parameter of the random walk MH for alpha_3 parameter}

\item{var_epsilon1}{Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm}

\item{var_epsilon2}{Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm}

\item{alpha_nu}{Double containing hyperparameter for sampling from tau_nu}

\item{beta_nu}{Double containing hyperparameter for sampling from tau_nu (scale)}

\item{alpha_eta}{Double containing hyperparameter for sampling from tau_eta}

\item{beta_eta}{Double containing hyperparameter for sampling from tau_eta (scale)}

\item{alpha_0}{Double containing hyperparameter for sampling from sigma}

\item{beta_0}{Double containing hyperparameter for sampling from sigma (scale)}
}
\value{
a List containing:
\describe{
  \item{\code{B}}{The basis functions evaluated at the observed time points}
  \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
  \item{\code{eta}}{Eta samples from the chain with the highest average log-likelihood}
  \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
  \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
  \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
  \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
  \item{\code{sigma}}{Sigma samples from the chain with the highest average log-likelihood}
  \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
  \item{\code{tau_eta}}{Tau_Eta samples from the chain with the highest average log-likelihood}
  \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
  \item{\code{loglik}}{Log-likelihood plot of best performing chain}
}
}
\description{
Function for finding a good initial starting point for nu, eta, and Z
parameters for functional data. This
function tries running multiple different MCMC chains to find the optimal
starting position. This function will return the chain that has the highest
log-likelihood average in the last 100 MCMC iterations.
}
\section{Warning}{

The following must be true:
\describe{
  \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
  \item{\code{n_try}}{must be an integer larger than or equal to 1}
  \item{\code{k}}{must be an integer larger than or equal to 2}
  \item{\code{n_funct}}{must be an integer larger than 1}
  \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
  \item{\code{n_eigen}}{must be greater than or equal to 1}
  \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
  \item{\code{c}}{must be greater than 0 and have k elements}
  \item{\code{b}}{must be positive}
  \item{\code{alpha1l}}{must be positive}
  \item{\code{beta1l}}{must be positive}
  \item{\code{alpha2l}}{must be positive}
  \item{\code{beta1l}}{must be positive}
  \item{\code{a_Z_PM}}{must be positive}
  \item{\code{a_pi_PM}}{must be positive}
  \item{\code{var_alpha3}}{must be positive}
  \item{\code{var_epsilon1}}{must be positive}
  \item{\code{var_epsilon2}}{must be positive}
  \item{\code{alpha_nu}}{must be positive}
  \item{\code{beta_nu}}{must be positive}
  \item{\code{alpha_eta}}{must be positive}
  \item{\code{beta_eta}}{must be positive}
  \item{\code{alpha_0}}{must be positive}
  \item{\code{beta_0}}{must be positive}
}
}

\examples{
## Load sample data
Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))

## Set Hyperparameters
tot_mcmc_iters <- 150
n_try <- 1
k <- 2
n_funct <- 40
basis_degree <- 3
n_eigen <- 3
boundary_knots <- c(0, 1000)
internal_knots <- c(250, 500, 750)

X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)
## Run function
x <- BFMMM_Nu_Z_multiple_try_Cov_Adj(tot_mcmc_iters, n_try, k, Y, time, X,
                                     n_funct, basis_degree, n_eigen,
                                     boundary_knots, internal_knots)

}
