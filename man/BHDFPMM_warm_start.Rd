% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{BHDFPMM_warm_start}
\alias{BHDFPMM_warm_start}
\title{Performs MCMC for high dimensional functional model given an informed set of starting points}
\usage{
BHDFPMM_warm_start(
  tot_mcmc_iters,
  k,
  Y,
  time,
  n_funct,
  basis_degree,
  n_eigen,
  boundary_knots,
  internal_knots,
  Z_samp,
  pi_samp,
  alpha_3_samp,
  delta_samp,
  gamma_samp,
  Phi_samp,
  A_samp,
  nu_samp,
  tau_samp,
  sigma_samp,
  chi_samp,
  burnin_prop = 0.8,
  dir = NULL,
  thinning_num = 1,
  beta_N_t = 1,
  N_t = 1L,
  n_temp_trans = 0L,
  r_stored_iters = 0L,
  c = NULL,
  b = 1,
  nu_1 = 3,
  alpha1l = 2,
  alpha2l = 3,
  beta1l = 1,
  beta2l = 1,
  a_Z_PM = 1000,
  a_pi_PM = 1000,
  var_alpha3 = 0.05,
  var_epsilon1 = 1,
  var_epsilon2 = 1,
  alpha = 1,
  beta = 10,
  alpha_0 = 1,
  beta_0 = 1
)
}
\arguments{
\item{tot_mcmc_iters}{Int containing the total number of MCMC iterations}

\item{k}{Int containing the number of clusters}

\item{Y}{List of vectors containing the observed values}

\item{time}{List of matrices that contain the observed time points (each column is a dimension)}

\item{n_funct}{Int containing the number of functions}

\item{basis_degree}{Vector containing the desired basis degree for each dimension}

\item{n_eigen}{Int containing the number of eigenfunctions}

\item{boundary_knots}{Matrix containing the boundary knots for each dimension (each row is a dimension)}

\item{internal_knots}{List of vectors containing the internal knots for each dimension}

\item{Z_samp}{Cube containing initial chain of Z parameters (from \code{BFPMM_NU_Z_multiple_try})}

\item{pi_samp}{Matrix containing initial chain of pi parameters (from \code{BFPMM_NU_Z_multiple_try})}

\item{alpha_3_samp}{Vector containing initial chain of alpha_3 parameters (from \code{BFPMM_NU_Z_multiple_try})}

\item{delta_samp}{Matrix containing initial chain of delta parameters (from \code{BFPMM_Theta_est})}

\item{gamma_samp}{List of cubes containing initial chain of gamma parameters (from \code{BFPMM_Theta_est})}

\item{Phi_samp}{List of cubes containing initial chain of phi parameters (from \code{BFPMM_Theta_est})}

\item{A_samp}{Matrix containing initial chain of A parameters (from \code{BFPMM_Theta_est})}

\item{nu_samp}{Cube containing initial chain of nu parameters (from \code{BFPMM_NU_Z_multiple_try})}

\item{tau_samp}{Matrix containing initial chain of tau parameters (from \code{BFPMM_NU_Z_multiple_try})}

\item{sigma_samp}{Vector containing initial chain of sigma parameters (from \code{BFPMM_Theta_est})}

\item{chi_samp}{Cube containing initial chain of chi parameters (from \code{BFPMM_Theta_est})}

\item{burnin_prop}{Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters}

\item{dir}{String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)}

\item{thinning_num}{Int containing how often we should save MCMC iterations}

\item{beta_N_t}{Double containing the maximum weight for tempered transitions}

\item{N_t}{Int containing total number of tempered transitions}

\item{n_temp_trans}{Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)}

\item{r_stored_iters}{Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)}

\item{c}{Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)}

\item{b}{double containing hyperparamete for sampling from alpha_3}

\item{nu_1}{double containing hyperparameter for sampling from gamma}

\item{alpha1l}{Double containing hyperparameter for sampling from A}

\item{alpha2l}{Double containing hyperparameter for sampling from A}

\item{beta1l}{Double containing hyperparameter for sampling from A (scale)}

\item{beta2l}{Double containing hyperparameter for sampling from A (scale)}

\item{a_Z_PM}{Double containing hyperparameter of the random walk MH for Z parameter}

\item{a_pi_PM}{Double containing hyperparameter of the random walk MH for pi parameter}

\item{var_alpha3}{Double containing variance parameter of the random walk MH for alpha_3 parameter}

\item{var_epsilon1}{Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm}

\item{var_epsilon2}{Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm}

\item{alpha}{Double containing hyperparameter for sampling from tau}

\item{beta}{Double containing hyperparameter for sampling from tau (scale)}

\item{alpha_0}{Double containing hyperparameter for sampling from sigma}

\item{beta_0}{Double containing hyperparameter for sampling from sigma (scale)}
}
\value{
a List containing:
\describe{
  \item{\code{B}}{The basis functions evaluated at the observed time points}
  \item{\code{nu}}{Nu samples from the MCMC chain}
  \item{\code{chi}}{chi samples from the MCMC chain}
  \item{\code{pi}}{pi samples from the MCMC chain}
  \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
  \item{\code{A}}{A samples from MCMC chain}
  \item{\code{delta}}{delta samples from the MCMC chain}
  \item{\code{sigma}}{sigma samples from the MCMC chain}
  \item{\code{tau}}{tau samples from the MCMC chain}
  \item{\code{gamma}}{gamma samples from the MCMC chain}
  \item{\code{Phi}}{Phi samples from the MCMC chain}
  \item{\code{Z}}{Z samples from the MCMC chain}
  \item{\code{loglik}}{Log-likelihood plot of best performing chain}
}
}
\description{
This function is meant to be used after using \code{BHDFPMM_Nu_Z_multiple_try}
and \code{BHDFPMM_Theta_est}. This function will use the outputs of these two
functions to start the MCMC chain in a good location. Since the posterior distribution
can often be multimodal, it is important to have a good starting position.
To help move across modes, this function allows users to use tempered transitions
every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
and un-tempered transitions, we can allow the chain to explore multiple modes without
while keeping sampling relatively computationally efficient. To save on RAM usage, we
allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
of the chain is stored in the user specified directory (\code{dir}). The samples from each
parameter can be viewed using the following functions: \code{ReadFieldCube},
\code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
\code{ReadVec}.
}
\section{Warning}{

The following must be true:
\describe{
  \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
  \item{\code{burnin_prop}}{must be between 0 and 1}
  \item{\code{k}}{must be an integer larger than or equal to 2}
  \item{\code{n_funct}}{must be an integer larger than 1}
  \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
  \item{\code{n_eigen}}{must be greater than or equal to 1}
  \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
  \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
  \item{\code{n_thinning}}{must be a positive integer}
  \item{\code{beta_N_t}}{must be between 1 and 0}
  \item{\code{N_t}}{must be a positive integer}
  \item{\code{n_temp_trans}}{must be a non-negative integer}
  \item{\code{r_stored_iters}}{must be a non-negative integer}
  \item{\code{c}}{must be greater than 0 and have k elements}
  \item{\code{b}}{must be positive}
  \item{\code{nu_1}}{must be positive}
  \item{\code{alpha1l}}{must be positive}
  \item{\code{beta1l}}{must be positive}
  \item{\code{alpha2l}}{must be positive}
  \item{\code{beta1l}}{must be positive}
  \item{\code{a_Z_PM}}{must be positive}
  \item{\code{a_pi_PM}}{must be positive}
  \item{\code{var_alpha3}}{must be positive}
  \item{\code{var_epsilon1}}{must be positive}
  \item{\code{var_epsilon2}}{must be positive}
  \item{\code{alpha}}{must be positive}
  \item{\code{beta}}{must be positive}
  \item{\code{alpha_0}}{must be positive}
  \item{\code{beta_0}}{must be positive}
}
}

\examples{
## Load sample data
Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFPMM"))
time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFPMM"))

## Set Hyperparameters
tot_mcmc_iters <- 150
n_try <- 1
k <- 2
n_funct <- 20
basis_degree <- c(2,2)
n_eigen <- 2
boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
internal_knots <- rep(list(c(250, 500, 750)), 2)

## Run function
est1 <- BHDFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
                                  basis_degree, n_eigen, boundary_knots,
                                  internal_knots)

## Run function
est2 <- BHDFPMM_Theta_est(tot_mcmc_iters, k, Y, time, n_funct,
                        basis_degree, n_eigen, boundary_knots,
                        internal_knots, est1$Z, est1$nu)

MCMC.chain <-BHDFPMM_warm_start(tot_mcmc_iters, k, Y, time, n_funct,
                                basis_degree, n_eigen, boundary_knots,
                                internal_knots, est1$Z, est1$pi, est1$alpha_3,
                                est2$delta, est2$gamma, est2$Phi, est2$A,
                                est1$nu, est1$tau, est2$sigma, est2$chi)

}
