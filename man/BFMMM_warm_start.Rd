% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{BFMMM_warm_start}
\alias{BFMMM_warm_start}
\title{Performs MCMC for functional models given an informed set of starting points}
\usage{
BFMMM_warm_start(
  tot_mcmc_iters,
  K,
  Y,
  time,
  n_funct,
  basis_degree,
  n_eigen,
  boundary_knots,
  internal_knots,
  multiple_try,
  theta_est,
  X = NULL,
  burnin_prop = 0.8,
  dir = NULL,
  thinning_num = 1,
  beta_N_t = 1,
  N_t = 1L,
  n_temp_trans = 0L,
  r_stored_iters = 0L,
  c = NULL,
  b = 10,
  nu_1 = 3,
  alpha1l = 2,
  alpha2l = 3,
  beta1l = 2,
  beta2l = 2,
  a_Z_PM = 10000,
  a_pi_PM = 1000,
  var_alpha3 = 0.05,
  var_epsilon1 = 1,
  var_epsilon2 = 1,
  alpha_nu = 10,
  beta_nu = 1,
  alpha_eta = 10,
  beta_eta = 1,
  alpha_0 = 1,
  beta_0 = 1,
  covariance_adj = FALSE
)
}
\arguments{
\item{tot_mcmc_iters}{Int containing the total number of MCMC iterations}

\item{K}{Int containing the number of clusters}

\item{Y}{List of vectors containing the observed values}

\item{time}{List of vectors containing the observed time points}

\item{n_funct}{Int containing the number of functions}

\item{basis_degree}{Int containing the degree of B-splines used}

\item{n_eigen}{Int containing the number of eigenfunctions}

\item{boundary_knots}{Vector containing the boundary points of our index domain of interest}

\item{internal_knots}{Vector location of internal knots for B-splines}

\item{multiple_try}{List containing results from \code{BFMMM_Nu_Z_multiple_try}}

\item{theta_est}{List containing results from \code{BFMMM_Theta_est}}

\item{X}{Matrix of covariates, where each row corresponds to an observation (if covariate adjusted)}

\item{burnin_prop}{Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters}

\item{dir}{String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)}

\item{thinning_num}{Int containing how often we should save MCMC iterations}

\item{beta_N_t}{Double containing the maximum weight for tempered transitions}

\item{N_t}{Int containing total number of tempered transitions}

\item{n_temp_trans}{Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)}

\item{r_stored_iters}{Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)}

\item{c}{Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)}

\item{b}{double containing hyperparamete for sampling from alpha_3}

\item{nu_1}{double containing hyperparameter for sampling from gamma}

\item{alpha1l}{Double containing hyperparameter for sampling from A}

\item{alpha2l}{Double containing hyperparameter for sampling from A}

\item{beta1l}{Double containing hyperparameter for sampling from A (scale)}

\item{beta2l}{Double containing hyperparameter for sampling from A (scale)}

\item{a_Z_PM}{Double containing hyperparameter of the random walk MH for Z parameter}

\item{a_pi_PM}{Double containing hyperparameter of the random walk MH for pi parameter}

\item{var_alpha3}{Double containing variance parameter of the random walk MH for alpha_3 parameter}

\item{var_epsilon1}{Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm}

\item{var_epsilon2}{Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm}

\item{alpha_nu}{Double containing hyperparameter for sampling from tau_nu}

\item{beta_nu}{Double containing hyperparameter for sampling from tau_nu (scale)}

\item{alpha_eta}{Double containing hyperparameter for sampling from tau_eta}

\item{beta_eta}{Double containing hyperparameter for sampling from tau_eta (scale)}

\item{alpha_0}{Double containing hyperparameter for sampling from sigma_sq}

\item{beta_0}{Double containing hyperparameter for sampling from sigma_sq (scale)}

\item{covariance_adj}{Boolean containing whether or not the covariance structure should depend on the covariates}
}
\value{
a List containing:
\describe{
  \item{\code{B}}{The basis functions evaluated at the observed time points}
  \item{\code{nu}}{Nu samples from the MCMC chain}
  \item{\code{chi}}{chi samples from the MCMC chain}
  \item{\code{pi}}{pi samples from the MCMC chain}
  \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
  \item{\code{A}}{A samples from MCMC chain}
  \item{\code{delta}}{delta samples from the MCMC chain}
  \item{\code{sigma_sq}}{sigma_sq samples from the MCMC chain}
  \item{\code{tau}}{tau samples from the MCMC chain}
  \item{\code{tau_eta}}{tau_eta samples from the MCMC chain (if covariate adjusted)}
  \item{\code{eta}}{eta samples from the MCMC chain (if covariate adjusted)}
  \item{\code{xi}}{xi samples from the MCMC chain (if covariance_adj is true)}
  \item{\code{delta_xi}}{delta_xi samples from the MCMC chain (if covariance_adj is true)}
  \item{\code{gamma_xi}}{gamma_xi samples from the MCMC chain (if covariance_adj is true)}
  \item{\code{A_xi}}{A_xi samples from the MCMC chain (if covariance_adj is true)}
  \item{\code{gamma}}{gamma samples from the MCMC chain}
  \item{\code{Phi}}{Phi samples from the MCMC chain}
  \item{\code{Z}}{Z samples from the MCMC chain}
  \item{\code{loglik}}{Log-likelihood plot of best performing chain}
}
}
\description{
This function is meant to be used after using \code{BFMMM_Nu_Z_multiple_try}
and \code{BFMMM_Theta_est}. This function will use the outputs of these two
functions to start the MCMC chain in a good location. Since the posterior distribution
can often be multimodal, it is important to have a good starting position.
To help move across modes, this function allows users to use tempered transitions
every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
and un-tempered transitions, we can allow the chain to explore multiple modes without
while keeping sampling relatively computationally efficient. To save on RAM usage, we
allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
of the chain is stored in the user specified directory (\code{dir}). The samples from each
parameter can be viewed using the following functions: \code{ReadFieldCube},
\code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
\code{ReadVec}. To specify a covariate
adjusted model, please provide the design matrix X.
}
\section{Warning}{

The following must be true:
\describe{
  \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
  \item{\code{X}}{ must have n_funct number of rows}
  \item{\code{burnin_prop}}{must be between 0 and 1}
  \item{\code{K}}{must be an integer larger than or equal to 2}
  \item{\code{n_funct}}{must be an integer larger than 1}
  \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
  \item{\code{n_eigen}}{must be greater than or equal to 1}
  \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
  \item{\code{X}}{must have n_funct number of rows (if specified)}
  \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
  \item{\code{n_thinning}}{must be a positive integer}
  \item{\code{beta_N_t}}{must be between 1 and 0}
  \item{\code{N_t}}{must be a positive integer}
  \item{\code{n_temp_trans}}{must be a non-negative integer}
  \item{\code{r_stored_iters}}{must be a non-negative integer}
  \item{\code{c}}{must be greater than 0 and have K elements}
  \item{\code{b}}{must be positive}
  \item{\code{nu_1}}{must be positive}
  \item{\code{alpha1l}}{must be positive}
  \item{\code{beta1l}}{must be positive}
  \item{\code{alpha2l}}{must be positive}
  \item{\code{beta1l}}{must be positive}
  \item{\code{a_Z_PM}}{must be positive}
  \item{\code{a_pi_PM}}{must be positive}
  \item{\code{var_alpha3}}{must be positive}
  \item{\code{var_epsilon1}}{must be positive}
  \item{\code{var_epsilon2}}{must be positive}
  \item{\code{alpha_nu}}{must be positive}
  \item{\code{beta_nu}}{must be positive}
  \item{\code{alpha_eta}}{must be positive}
  \item{\code{beta_eta}}{must be positive}
  \item{\code{alpha_0}}{must be positive}
  \item{\code{beta_0}}{must be positive}
}
}

\examples{
#########################
### Not Covariate Adj ###
#########################

## Load sample data
Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))

## Set Hyperparameters
tot_mcmc_iters <- 150
n_try <- 1
K <- 2
n_funct <- 40
basis_degree <- 3
n_eigen <- 3
boundary_knots <- c(0, 1000)
internal_knots <- c(250, 500, 750)

## Get Estimates of Z and nu
est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
                                basis_degree, n_eigen, boundary_knots,
                                internal_knots)

## Run function
est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
                        basis_degree, n_eigen, boundary_knots,
                        internal_knots, est1)

## Run MCMC sampler
MCMC.chain <- BFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
                               basis_degree, n_eigen, boundary_knots,
                               internal_knots, est1, est2)

#####################
### Covariate Adj ###
#####################

## Load sample data
Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))

## Set Hyperparameters
tot_mcmc_iters <- 150
n_try <- 1
K <- 2
n_funct <- 40
basis_degree <- 3
n_eigen <- 3
boundary_knots <- c(0, 1000)
internal_knots <- c(250, 500, 750)

X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)

## Get Estimates of Z and nu
est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
                                basis_degree, n_eigen, boundary_knots,
                                internal_knots, X = X)

## Run function
est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
                        basis_degree, n_eigen, boundary_knots,
                        internal_knots, est1, X = X)

## Run MCMC sampler
MCMC.chain <- BFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
                               basis_degree, n_eigen, boundary_knots,
                               internal_knots, est1, est2, X = X)

#####################################################################
### Covariate Adj  (with Covariate-depenent covariance structure) ###
#####################################################################

## Load sample data
Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFMMM"))
time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFMMM"))

## Set Hyperparameters
tot_mcmc_iters <- 150
n_try <- 1
K <- 2
n_funct <- 40
basis_degree <- 3
n_eigen <- 3
boundary_knots <- c(0, 1000)
internal_knots <- c(250, 500, 750)

X <- matrix(rnorm(40, 0 , 1), nrow = 40, ncol = 1)

## Get Estimates of Z and nu
est1 <- BFMMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, K, Y, time, n_funct,
                                basis_degree, n_eigen, boundary_knots,
                                internal_knots, X = X)

## Run function
est2 <- BFMMM_Theta_est(tot_mcmc_iters, n_try, K, Y, time, n_funct,
                        basis_degree, n_eigen, boundary_knots,
                        internal_knots, est1, X = X, covariance_adj = T)

## Run MCMC sampler
MCMC.chain <- BFMMM_warm_start(tot_mcmc_iters, K, Y, time, n_funct,
                               basis_degree, n_eigen, boundary_knots,
                               internal_knots, est1, est2, X = X, covariance_adj = T)
}
